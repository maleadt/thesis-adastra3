\part{Ontwerp}
\label{ontwerp}

%
% Systeemmodel
%

\chapter{Systeemmodel}
\label{ontwerp:systeemmodel}

De eerste stap van het ontwerp was de identificatie van de verschillende deelsystemen, en op welke toestellen die te vinden zijn. Hiertoe hebben we eerst gekeken naar de verschillende taken die het systeem als een geheel moet vervullen. Zo moet het systeem:
\begin{itemize}
\item Voorstellingen weergeven, en gebruikersinvoer verwerken;
\item Toelaten om eenvoudig voorstellingen te wijzigen, zonder veel technische bagage;
\item Voorzien in een gebruiksvriendelijke beheerinterface;
\item Dit alles voldoende robuust uitvoeren.
\end{itemize}

Hiermee konden we de verschillende deelsystemen identificeren. Zo zijn er natuurlijk de kiosken, die instaan voor de weergave van de voorstellingen, en de verwerking van gebruikersinvoer. Om het systeem flexibel te houden, zullen we de kiosken zo inrichten dat zowel de configuratie als de weer te geven voorstellingen zich niet op voorhand op de kiosk bevinden, maar van een centrale server gehaald worden. Diezelfde centrale server kan dan ook voorzien in een beheerinterface, waarbij de status van de verschillende kiosken gevisualiseerd wordt, en de administrator eventueel bepaalde acties kan ondernemen. Al deze functionaliteit zullen we bundelen binnen het specifiek hiervoor ontworpen applicatie-raamwerk, waarvoor we ook een communicatieprotocol zullen moeten definiëren.

In de volgende hoofdstukken gaan we elk van deze deelsystemen, en al wat daar bij hoort, tot in details uitwerken. Zo zullen we ook frequent bestaande technologieën hergebruiken, of net een gerichte keuze maken zodat hergebruik mogelijk wordt. Daarbij gaan we meestal uit van een initiële selectie aan technologieën die gebruikt kan worden om een specifiek doel te bekomen, waarna de selectie uitgedund wordt tot er slechts 1 mogelijkheid overblijft. Het valt op te merken dat we bij dergelijke selectieprocedures steeds een impliciete doch sterke voorkeur stellen voor open technologieën, waarvoor er een gratis, cross-platform en open-source implementatie bestaat. Dat we kiezen voor technologieën met een kosteloze implementatie, vloeit voort uit het beperkte budget dat toegekend is door de MIRA vzw. Het cross-platform aspect is belangrijk omdat op termijn de applicatie misschien op een ander systeem zal moeten draaien, alsook zal het in geval van een succesvol eindproduct de openstelling voor andere bedrijven bevorderen. Het open-source kenmerk tenslotte kent zijn oorsprong weliswaar deels in idealistische gronden, maar blijkt in de praktijk ook zeer praktisch te zijn. Zo is het tijdens de realisatie van het project verschillende keren extreem nuttig gebleken om vrije toegang te hebben tot de broncode van de bibliotheek.


%
% Applicatie
%

\chapter{Applicatie}
\label{ontwerp:applicatie}

In volgende hoofdstuk bespreken we het ontwerp van de applicatie. Daarbij zullen we eerst de technologieën vastleggen, om vervolgens het exacte gebruik ervan te documenteren. Hiertoe hebben we vaak gebruik gemaakt van prototypes: kleine applicaties die gebruik maken van de technologie of bibliotheek in kwestie, om zo op voorhand reeds zicht te hebben op de kwaliteit ervan.

In realiteit was dit proces echter niet zo afgelijnd: vaak leidde een bepaalde beslissing tot het terugkomen op een voorheen gemaakte keuze. In meerdere gevallen zal het dan ook voorkomen dat een specifieke eis uit het niets gegrepen lijkt, of bevooroordeeld schijnt te zijn. Toch is dit niet het geval, pas na afloop van het hoofdstuk zal het totale plaatje duidelijk worden, nadat alle beslissingen mooi in de plooi gevallen zijn.

\section{Voorstellingen}
\label{ontwerp:applicatie:voorstellingen}

\subsection{Formaat}

Aan het formaat van de voorstellingen worden een aantal specifieke eisen gesteld:
\begin{itemize}
\item Terugwaarts compatibel met de huidige voorstellingen;
\item Efficiënt te distribueren over het netwerk;
\item Flexibel en toekomstgericht;
\item Eenvoudig weer te geven;
\item Laagdrempelig.
\end{itemize}

Zoals reeds gezegd bevinden de oude voorstellingen zich op een Dvd-schijf, in videoformaat. Het nieuwe formaat moet dus in staat zijn om video's weer te geven, eventueel na bepaalde conversies (herwerken van alle bestaande media is immers niet haalbaar).

Het eerste idee was dan ook om de reeds digitale \strong{Dvd-bronbestanden te streamen} naar de kiosken. Een eerste probleem met deze opzet is de grootte van de bronbestanden (gemiddeld $3 GB$ per Dvd), wat enerzijds voldoende opslagcapaciteit vereist aan de kant van de server, en het anderzijds moeilijk maakt om het geheel te cachen aan de kant van de kiosk waardoor zowel de server als het netwerk aan een continue belasting zullen onderworpen worden. Die netwerkbelasting is tevens niet van de minste: de Dvd-standaard beschrijft dat de videobestanden een piekbitrate van maar liefst $10 Mb/s$ kunnen hebben, waardoor de server alsook de infrastructuur zouden moeten voorzien in hardware die tot $1 Gb/s$ moet kunnen verwerken.

Om deze problemen op te lossen hebben we gedacht aan het \strong{streamen van gecomprimeerde videobestanden}. Indien we bijvoorbeeld de video comprimeren met de moderne \code{H264} compressiestandaard (getest met de \code{x264} encoder en diens standaard compressieparameters), reduceren we de piekbitrate tot $2.5 Mb/s$ zonder daarbij te moeten inboeten aan kwaliteit. Toch kunnen we dit nog steeds niet efficiënt noemen, vooral omdat eerder statische of zelfs puur tekstuele gegevens nog steeds voorgesteld worden door videogegevens. Ook is het systeem niet flexibel: complexe logica of interactieve voorstellingen kunnen niet of maar heel omslachtig gerealiseerd worden.

Daarom hebben we het over een andere boeg gegooid en gekeken naar \strong{specialistische presentatieformaten}, zoals het \code{Powerpoint} of \code{OpenDocument Presentation} formaat. Hierbij is het veel eenvoudiger om complexe en interactieve voorstellingen te realiseren, alsook worden die gegevens efficiënt en flexibel opgeslagen. Ook kunnen we de bestaande videobestanden gebruiken binnen de voorstellingen, afhankelijk van het presentatieformaat door ze erin te verwerken of door te verwijzen naar een extern bestand. Maar dit systeem is niet ideaal: weergeven van de bestanden buiten de applicatie waarvoor ze ontwikkeld is om, is niet eenvoudig. Ook is het vervelend dat het eindresultaat bestaat uit een binair bestand, waardoor het bijvoorbeeld moeilijk wordt om wijzigingen te detecteren en zo efficiënte overdracht te realiseren.

Om toch de voordelen van speciale presentatieformaten te benutten, zullen we ze implementeren met \strong{\ac{html} en Javascript}, een veelgebruikte combinatie bij het maken van moderne websites. Hierbij is het nog steeds mogelijk om complexe voorstellingen te realiseren, en worden die efficiënt opgeslagen. Alle code wordt immers opgeslagen in tekstformaat, en de ondersteunde video- en audiostandaarden zijn steeds gekozen wegens hun efficiënte netwerkoverdracht. Verder kunnen ook afbeeldingen en video's efficiënt gemaakt worden door ze te realiseren in een vectorformaat\footnote{Afbeeldingen via het \code{<svg>} element, en video's via \code{<canvas>} en Javascript code.}. Ook biedt \ac{html} sinds versie 5 de mogelijkheid om multimediabestanden weer te geven (via de \code{<video>} en \code{<audio>} tags), waardoor we de terugwaartse compatibiliteit met het huidige systeem bekomen. Een ander vorodeel is dat erer enorm veel Javascript codebibliotheken bestaan, waardoor het via hergebruik daarvan mogelijk wordt om zeer dynamische voorstellingen te realiseren. Tenslotte is het ook eenvoudig om dergelijke bestanden weer te geven in een externe applicatie, door gebruik te maken van bestaande rendering engines. Een minpunt is wel de manier waarop de logica geïmplementeerd is: de designer moet steeds een notie van Javascript hebben. Het is wellicht mogelijk om zoveel mogelijk te abstraheren in een externe Javascript bibliotheek, maar toch blijft de scheiding tussen design en code vager dan bij de andere systemen. Ook bestaan er (nog) geen bruikbare \ac{wysiwyg} editors, waardoor het steeds nodig is om \ac{html} code, hoe laagdrempelig die ook is, handmatig te schrijven.

\begin{table}[h!]
  \begin{center}
    \begin{tabular}{p{3cm} p{4cm} p{4cm}}
    & Dvd-bronbestanden & Compressie \\
    \hline
    Compatibiliteit & Volledig compatibel & Mits conversie \\
    Efficiëntie & Inefficiënt & Inefficiënt \\
    Flexibiliteit & Zeer omslachtig & Zeer omslachtig \\
    Externe weergave & Eenvoudig & Eenvoudig \\
    Complexiteit & Relatief eenvoudig & Relatief eenvoudig \\
    \\    
    & Presentatieformaten & \ac{html} en Javascript \\
    \hline
    Compatibiliteit & Embedden & Embedden na conversie \\
    Efficiëntie & Efficiënt & Zeer efficiënt \\
    Flexibiliteit & Flexibel & Extreem flexibel \\
    Externe weergave & Moeilijk & Relatief eenvoudig \\
    Complexiteit & Zeer eenvoudig & Relatief moeilijk \\
    \end{tabular}
  \end{center}
  \caption{Vergelijking van verschillende formaten.}
\end{table}

Na zorgvuldig afwegen van de voor- en nadelen hebben we gekozen voor de combinatie van \ac{html} en Javascript, aangezien het als enigste systeem voldoet aan alle functionele eisen. Het grote minpunt, de moeilijkheid om voorstellingen te wijzigen wegens de mindere duidelijke scheiding tussen design en code, zal immers verbeteren na verloop van tijd. Zo zullen er wellicht Javascript-bibliotheken ontwikkeld worden om presentatielogica te abstraheren, en kan het best zijn dat er binnenkort betere \ac{wysiwyg}-editors voor moderne \ac{html} zullen verschijnen.\footnote{Op het moment van schrijven heet Adobe zonet Adobe Edge aangekondigd, een editor om eenvoudig animaties met \ac{html} en \ac{css} te maken.}

\subsection{Repository}

Zoals hierboven reeds vermeld, zullen noch de nieuwste voorstellingen noch de configuratie zich direct op de relevante kiosken bevinden, maar dynamisch van de centrale server gedownload worden. Indien we ook zorgen voor een een gebruiksvriendelijk systeem om de media te wijzigen, maakt dit het leven van de administrator ook een pak gemakkelijker nu hij de relevante bestanden niet langer naar elke kiosk apart moet sturen maar louter op de centrale server plaatsen.

Initieel dachten we dit te doen met een \strong{database-systeem}. Hoewel dergelijke systemen vooral sterk zijn in het herbergen van gestructureerde data, zou het perfect mogelijk zijn om er de eerder bestandsgeoriënteerde voorstellingen in op te slaan. Voor efficiënte overdracht zouden we wel zelf moeten zorgen, en bovendien zou het vrij arbeidsintensief zijn om een gebruiksvriendelijke interface te bouwen bovenop dit systeem.

Een andere verzameling technologieën die we overwogen hebben, waren de \strong{Enterprise Content Management} systemen. Hierbij vinden we al vaker een geïntegreerde beheerinterface, alsook komt het frequent voor dat een reeds aanwezig versiebeheer-systeem zorgt voor efficiënte dataoverdracht. Toch zijn we blijven zoeken naar andere oplossingen, omdat bij deze systemen de nadruk vaak nog explicieter ligt op gestructureerde data, waardoor het niet praktisch zou zijn om er onze ongestructureerde voorstellingen in op te slaan.

Daarom hebben we uiteindelijk te stap gemaakt naar speciale \strong{versiebeheer-systemen}. Hierbij is efficiënte overdracht van gegevens een basiseigenschap, en zorgt het bestandsgeoriënteerde aspect tegelijkertijd voor een relatief gebruiksvriendelijke interface. Zo kan een administrator heel gemakkelijk lokaal enkele wijzigingen doorvoeren aan een voorstelling, het resultaat testen in zijn browser, en indien gewenst zijn werk doorsturen naar de centrale server. Ook zorgt het ervoor dat het in eerste instantie niet nodig is om te voorzien in extra software om überhaupt met de bestanden te kunnen werken, maar blijft het wel nog steeds mogelijk om dit later te doen en zo het proces gebruiksvriendelijker te maken.

Er bestaan echter tientallen versiebeheersystemen, die we elk gepeild hebben aan ons eisenpakket:
\begin{itemize}
\item Client-server georiënteerd;
\item Client-side gedeelte eenvoudig te gebruiken vanuit een applicatie;
\item Server-side gedeelte liefst ook te integreren binnen een andere applicatie;
\item Efficiënte omgang met binaire bestanden.
\end{itemize}

Er zijn maar weinig versiebeheersystemen die aan dit eisenpakket voldoen. Meer nog, na een uitgebreide vergelijking blijkt enkel \ac{svn} een geschikte keuze te zijn. Dit ondertussen ruim 10 jaar oud project biedt ons een goed ontwikkeld en stabiel versiebeheersysteem om onze repository mee te realiseren. Ook voorziet het project in een uitgebreide library die toelaat om de repository direct te manipuleren vanuit een externe applicatie. Hierdoor zal relatief eenvoudig zijn om vanuit de client- en serverapplicatie bestanden op te vragen uit de repository, door gebruik te maken van de clientside-bindings in de \ac{svn} bibliotheek. Ook zou het interessant geweest zijn om voor de serverapplicatie een nog hechtere integratie realiseren, waarbij de repository zich eigenlijk binnen de applicatie zou bevinden. Dit zou als voordeel gehad hebben dat we niet zouden moeten berusten op een externe \ac{svn} instantie, maar zoals later zal blijken hebben we uiteindelijk dit idee moeten opgeven.

\subsubsection{Layout}

Hoewel we nu gekozen hebben voor een bestandsgeoriënteerde \ac{svn}-repository, ligt de exacte layout van de bestanden daarin nog niet vast. Aangezien zowel de voorstellingen als de kioskconfiguratie erin zal moeten opgeslagen worden, is het belangrijk om op voorhand een eenduidige structuur vast te leggen die tevens toelaat om eenvoudig wijzigingen te detecteren.

\begin{lstlisting}[float, caption=Voorbeeld van een repository layout.]
+-repository/
  |
  +-configurations/
  | |
  | +-kiosk1.xml
  | |
  | +-kiosk2.xml
  |
  +-media/
    |
    +-presentation1/
      |
      +-index.html
\end{lstlisting}

Op het hoogste niveau zal de repository bestaan uit twee mappen. In de \code{configurations} map bevinden zich bestanden die een configuratie typeren, elk uniek geïdentificeerd door hun bestandsnaam. Een configuratie bepaalt volledig hoe een kiosk zich zal gedragen, zoals welke media ingeladen moet worden of hoe sterk het volume moet staan. Om de implementatie eenvoudig te houden hebben we ervoor gekozen om een een configuratie eenduidig te laten overeenkomen met een enkele kiosk, en niet te voorzien in functionaliteit om gedeelde instellingen weg te werken naar een overkoepelende configuratie. Natuurlijk laat het formaat toe om dit in een later stadium toe te voegen.

De \code{media} map bevat de effectieve voorstellingen, elk in een aparte map. Hierin staan de bestanden nodig om de voorstelling weer te geven, waarbij slechts 1 bestand echt vereist is: \code{index.html}. Dit bestand is het ingangspunt in de voorstelling: het zal door de client ingeladen worden wanneer de presentatie moet weergegeven worden. Het zou natuurlijk mogelijk zijn om dit op een flexibelere manier op te lossen, bijvoorbeeld via een extra configuratiebestand, maar opnieuw kiezen we ervoor om initieel een eenvoudig maar functioneel raamwerk te voorzien en pas in een later stadium eventueel te voorzien in extra features.

\paragraph{Bestandsformaat}

Voor de voorstellingen is het reeds duidelijk welk formaat de bestanden moeten hebben, namelijk geldige HTML code. Bij de configuratiebestanden daarentegen moeten we zelf nog op zoek gaan naar een gepast formaat om de informatie in op te slaan. Hierbij zullen we opnieuw eerst bepalen wat onze eisen zijn:
\begin{itemize}
  \item Eenvoudig te bewerken;
  \item In te laden vanuit een externe applicatie, zonder daarbij al te veel werk te moeten verrichten;
  \item Correctheid moet te verifiëren vallen.
\end{itemize}

Als eerste kandidaat hebben we gekeken naar het \strong{INI formaat}, een populair \code{key=value} formaat dat zijn origines kent binnen oudere Windows versies. Hoewel dit eigenlijk helemaal geen krachtig formaat is, leek het interessant omdat het eenvoudig te bewerken en relatief intuïtief is. Ook zijn er veel bibliotheken beschikbaar om dergelijke bestanden in te lezen, al moet het gezegd zijn dat het voor zo een eenvoudig formaat eigenlijk helemaal niet nodig is om op zoek te gaan naar een speciale biblitoheek.

Van zodra we echter begonnen aan de effectieve implementatie van de applicaties, bleek het formaat niet voldoende voor onze toepassing. Zo hadden we op een gegeven moment nood aan een hierarchische datastructuur, wat bij een ini-bestand onmogelijk is. Ook hebben we een tijdje last gehad van een bug die veroorzaakt werd door een typfout in een configuratiebestand, iets dat de parser niet detecteerde bij gebrek aan validagiemogelijkheden. Daarom hebben we besloten om op zoek te gaan naar een alternatief, dat we gevonden hebben onder de vorm van \strong{\ac{xml} bestanden}. Dit formaat kent enkele duidelijke voordelen: zo is het mogelijk om hierarchische datastructuren te modelleren, en bestaan er verschillende mechanismen om de bestanden te verifiëren vooraleer ze effectief in te laden. Voor dat laatste zullen we kiezen voor \ac{xml} schema, waartoe we eerst een \ac{xsd} bestand zullen moeten maken dat het exacte formaat van de configuratiebestanden formeel beschrijft. Ook bestaan er talloze bibliotheken om de bestanden in code in te laden. Toch kent het formaat een belangrijk nadeel: het is nu niet meer zo gebruiksvriendelijk om het met de hand te bewerken (zie bijvoorbeeld fragment \ref{lst:config}). Hiervoor zullen we in de toekomst misschien een kleine applicatie ontwerpen die een administrator toelaat om een kiosk te configureren via een gebruiksvriendelijke wizard, waarbij deze applicatie handig gebruik zal kunnen maken van het \ac{xsd} bestand. 

\begin{lstlisting}[language=XML, float, caption=Voorbeeld van een kiosk configuratiebstand., label=lst:config]
<?xml version="1.0"?>
<kiosk xmlns="http://www.mira.be">
  <target>
    0026b900-926f-1000-8000-000000000000
  </target>
  <device>
    <sound>
      <volume>255</volume>
    </sound>
  </device>
  <application>
    <media id="manen" />
  </application>
</kiosk>
\end{lstlisting}

De specificatie van de \ac{xml} bestanden is zodanig gemaakt dat het eenvoudig te mappen valt over de services waarmee de server een kiosk kan controleren (zie later).

\subsubsection{Verwerking}

Nu de gegevens binnen de repository gesplitst zijn in twee delen, de configuraties en de voorstellingen, valt het nog te bepalen welke component instaat voor de verwerking van elk van die gegevens. Betreffende de \strong{voorstellingen} is het eenvoudig te zien dat we best de client hiervoor verantwoordelijk stellen. Als we immers de server zouden gebruiken voor het ophalen van de media, dan moeten we zelf zorgen voor het efficiënt overdragen van de gegevens naar de client. Als we echter vanuit de client rechtstreeks contact opnemen met de repository maken we gebruik van het \ac{svn} protocol, wat verschillende optimalisaties voor efficiëntie heeft ingebouwd.

Voor de \strong{configuraties} is het een complexere afweging. Moesten we de configuraties laten verwerken door de clients, dan zouden we maar op 1 plek contact opnemen met de repository, wat natuurlijk de beste oplossing lijkt. Toch hebben we ervoor gekozen om de configuraties door de server te laten inlezen, wat essentieel twee grote nadelen heeft: de serverapplicatie vereist er een clientside \ac{svn} library door, en op de clients zullen we de nodige interfaces moeten voorzien om configuratie over het netwerk toe te laten. De motivatie voor deze keuze was als volgt:

\begin{enumerate}
\item Vooreerst is er het probleem van monitoring. Aangezien een beheerder op elk moment wijzigingen kan uploaden, moet de partij die verantwoordelijk is voor het ophalen van gegevens periodiek de repository controleren. Als we hiervoor de client zouden gebruiken, betekent dit dat een potentieel groot aantal clients periodiek contact opneemt met de server, wat niet echt efficiënt is. Ook is er het probleem van scheduling: als elke client volledig onafhankelijk de repository in de gaten houdt en handelt wanneer wijzigingen plaatsvinden, is het onmogelijk om extreme belasting van de server te vermijden door de clients slechts sequentieel toegang tot de repository te verlenen. Het is dus duidelijk dat we binnen de server sowieso een clientside \ac{svn} library zullen moeten voorzien.
\item Een tweede motivatie is de nood aan een krachtige configuratie-tool. Een administrator moet de mogelijkheid hebben om via een tool (hetzij een webinterface, hetzij een lokale applicatie) direct een actie teweeg te brengen op een kiosk naar keuze. Het kan bijvoorbeeld zijn dat een kiosk afgesloten moet worden, of dat heel snel al het geluid moet afgezet worden. Het is logisch dat dit buiten de repository om moet kunnen, en om dit te realiseren moeten de client-applicaties voorzien in een bepaalde interface die toelaat om acties teweeg te brengen.
\end{enumerate}

Het is dus duidelijk dat het geen extra complexiteit teweegbrengt om de configuraties binnen de serverapplicatie te verwerken (zowel een clientside \ac{svn} library als de nodige configuratieinterfaces zijn sowieso nodig), meer nog, het is een interessante oplossing omdat we zo tenminste de belasting van de server kunnen controleren door het updaten van de clients intelligent te schedulen.

\section{Netwerk}
\label{ontwerp:applicatie:netwerk}

De verschillende onderdelen van het systeem zullen niet enkel lokaal werken, maar ook met elkaar communiceren over het netwerk. Zo zullen de voorstellingen, waarvan we het formaat en reeds vastgelegd hebben, via het netwerk naar de kiosken overgedragen worden. Maar ook het beheer zal over het netwerk verlopen: via een centrale beheersapplicatie kan een werknemer de status van de kiosken te bekijken, en eventueel bepaalde acties te ondernemen. Die acties worden daarbij niet beperkt tot beheerstaken: om het geheel eenvoudig te houden zal hetzelfde mechanisme ook gebruikt worden om essentiële applicatiefunctionaliteit (zoals het inladen van een voorstelling, of het doorvoeren van de instellingen die de ingeladen configuratie vereist) te realiseren.

\subsection{Dataoverdracht}

Aangezien we gebruik maken van een losstaand versiebeheersysteem (zie \ref{ontwerp:applicatie:voorstellingen}), namelijk \ac{svn}, zullen we ook gebruik maken van diens dataoverdrachtmogelijkheden.

\subsection{Netwerkconfiguratie}

Om het systeem eenvoudig in gebruik te maken, hebben we er voor geopperd om zoveel mogelijk van de configuratie automatisch te laten verlopen. Er blijft echter steeds één link die manueel moet gelegd worden: namelijk welke voorstelling op welk kiosk moet getoond worden. Hoe we de overige configuratie automatiseren wordt besproken in de volgende paragrafen.

\subsubsection{Discovery}

Service discovery staat in voor het publiceren van en luisteren naar meldingen waarbij een toestel zijn diensten adverteert op een bepaald netwerkkanaal. Hierbij wordt vaak aangegeven wat de naam is van het toestel, en wat de exacte mogelijkheden zijn van elke dienst.
Zoals zo vaak het geval is, bestaan er verschillende technologieën die voorzien in dergelijke functionaliteit. Om een selectie te kunnen maken, stellen we enkele bijkomende eisen: 
\begin{itemize}
\item Vereist geen extra infrastructuur;
\item Cross-language implementatie;
\item Robuust en stabiel.
\end{itemize}

Een veelgebruikt protocol voor service discovery, is het \strong{\ac{ssdp}}, deel van het \ac{upnp} systeem. Dit door Microsoft-ontwikkeld systeem, biedt een heel uitgebreid en generisch raamwerk voor service discovery, waarbij die services volledig beschreven worden door het \ac{dcp}. Het geheel steunt sterk op \ac{xml} en \ac{soap}, en is strikt beheerd door het \ac{upnp} Forum. Hoewel het protocol essentieel wel voldoet aan onze eisen, is het niet zo eenvoudig in gebruik en biedt het veel te veel mogelijkheden die we toch niet allemaal gaan gebruiken.

Een compacter alternatief is \strong{\ac{mdns}}, onderdeel van het door Apple ontwikkelde Zeroconf systeem. Zoals de naam doet vermoeden, is dit een multicast uitbreiding van het \ac{dns}, dat de \code{SRV} records gebruikt om services te publiceren. Dit is een veel eleganter systeem, essentieel slechts een eenvoudige uitbreiding van een bestaande technologie, maar kent zo ook zijn tekortkomingen. Zo worden bijvoorbeeld de mogelijkheden van elke service gedetailleerd via een verder niet gespecificeerd tekstveld. Dergelijke tekortkomingen zijn echter niet van belang in de context van dit systeem, waardoor het min of meer evenwaardig is met \ac{ssdp}.

Wegens de eenvoud elegantie van het protocol, was de initiële implementatie dan ook gebaseerd op \ac{mdns} door gebruik te maken van de \code{JmDNS} bibliotheek. Na verloop van tijd bleek die bibliotheek echter niet zo stabiel: zo kwam het soms voor dat een kiosk die zichzelf gepubliceerd werd, niet door de server herkend werd. Aangezien dergelijke stabiliteitsproblemen totaal onaanvaardbaar zijn, en \code{JmDNS} de enige \ac{mdns} implementatie voor Java is (platformgebonden code hierbij niet in achting genomen), hebben we uiteindelijk moeten overschakelen naar \ac{upnp}.

\subsubsection{Adressering}

Hoewel we nu beschikken over een systeem dat zonder enige configuratie toelaat om een kiosk te vinden en contacteren, is er nog steeds nood aan een mechanisme die de netwerkinterfaces op de kiosken configureert. Maar omdat elk contact volledig dynamisch verloopt, maakt het eigenlijk niet uit welke adressen toegewezen worden aan individuele kiosken, de enige vereiste is dat de adressen legaal zijn waardoor netwerkcommunicatie correct kan verlopen.

De meest logische keuze hiervoor is het \ac{dhcp} protocol, een veelgebruikt en robuust protocol waarbij de kiosken bij het opstarten een aanvraag voor een adres broadcasten. Hierbij wordt rekening gehouden met welke adressen reeds ingenomen zijn, waardoor er geen conflicten zullen optreden bij het toewijzen van adressen. Een nadeel aan \ac{dhcp} is dat het nood heeft aan een serverapplicatie die instaat voor het uitdelen en beheren van adressen, maar aangezien we toch een router zullen nodig hebben binnen het netwerk en quasi elke router een \ac{dhcp} server aan boord heeft, vormt dit niet echt een probleem.

Een toekomstgericht alternatief dat we misschien in een volgende versie zouden kunnen implementeren, maakt gebruik van \ac{ip} versie 6, terwijl we voor de huidige setup kiezen voor \ac{ip} versie 4. Versie 6 kent immers een robuustere en snellere vorm van local-link adressering, waardoor het mogelijk zou zijn om de kiosken zichzelf volledig autonoom een adres te laten toekennen.

\subsection{Controle}

In eerste instantie, toen we er nog van uitgingen dat we geen \ac{upnp} zouden gebruiken, zijn we op zoek gegaan naar eenvoudige \emph{remote procedure} protocollen om zo zonder teveel overhead de nodige acties op de kiosken te kunnen teweegbrengen. In die categorie vinden we zo \strong{\ac{rest}}. Hoewel dit lichtgewicht, \ac{http}-gebaseerd, en ook veelgebruikt protocol op het eerste zicht aan onze eisen voldoet, kent het zijn mindere kanten. Zo kent het geen eenduidige manier om fouten terug te geven, alsook is het formaat waarin gegevens verstuurd worden niet gestandaardiseerd. Omdat de implementatie daarvan nog vrij veel werk zou vereisen, besteden we verder geen aandacht aan dit protocol.

De meest courante ontwikkelframeworks zoals .NET en Java kennen meestal ook hun eigen \ac{rpc}-protocol, zoals \strong{.NET Remoting} en \strong{\ac{rmi}}. Hoewel deze protocollen meestal goed doorontwikkeld en veelzijdig zijn, kunnen ze vaak maar op een enkel platform gebruikt worden en zijn ze al zeker niet cross-language.

Ook hebben we meer moderne \ac{rpc}-frameworks overwogen zoals \strong{Apache Etch}, of \strong{Apache Thrift}. Deze vrij nieuwe en tevens veelbelovende systemen bleken echter enkele kritieke eisen mis te lopen. Zo kent Apache Etch slechts weinig language bindings, en kent geen van beide een authenticatiemechanisme.

Vervolgens hebben we de nodige aandacht besteed aan \strong{XML-RPC}, een zeer simplistisch \ac{rpc}-protocol dat XML-geformatteerde berichten verstuurt over \ac{http}. Jammer genoeg kent XML-RPC enkele fundamentele problemen, zoals het inefficiënte berichtformaat. Ook is de specificatie, om het zacht uit te drukken, vrij beperkt. Dit kan echter een voordeel zijn: de ermee geïmplementeerde interface wordt er compact mee gehouden, en valt eenvoudig te gebruiken vanuit verschillende talen. Dit wordt verder vereenvoudigd door het groot aantal implementaties, voor de meeste talen zijn er verschillende te vinden.

Van zodra we echter het service discovery mechanisme overgezet hebben naar \ac{ssdp}, hebben we besloten om ook voor de acties gebruik te maken van \strong{\ac{upnp}}, dat de mogelijkheid biedt om bij het adverteren van een toestel te voorzien in verschillende \emph{services} en een exacte beschrijving van de verschillende acties die via die service kunnen ondernomen worden.

\subsection{Device en service descriptions}

Om een \ac{upnp} client na het ontdekken van een toestel en diens services toe te laten om het toestel ook effectief te controleren, heeft de client meer informatie nodig. Zo zal de client een \strong{device description} kunnen opvragen, waarin informatie staat die het toestel identificeert en gedeeltelijk beschrijft. Ook zullen we voor elk van zijn services moeten voorzien in een \strong{service description}. Beide zijn steeds opgemaakt als een \ac{scpd}: een \ac{xml} bestand met opmaak bepaald door de \ac{upnp} specificatie. Bij veel libraries moeten we echter nooit zelf de bestanden schrijven, maar worden ze gegenereerd via een hulpklasse of (zoals vaak het geval is bij libraries voor dynamische talen) worden ze via introspectie afgeleid van een relevante klasse.

\subsubsection{Device description}

Om ons toestel te laten voldoen aan de \ac{upnp} specificatie voorzien we in de volgende gegevens:

\begin{table}[h!]
  \begin{center}
    \begin{tabular}{r l}
    \hline
    Type & \texttt{urn:mira-be:device:Kiosk:1} \\
    Friendly name & Multimedia kiosk \\
    Manufacturer & Volkssterrenwacht MIRA vzw \\
    Manufacturer URL & www.mira.be \\
    Model description & Flexible network-enabled multimedia kiosk \\
    Model name & Ad-Astra Kiosk \\
    Model number & 3.0 \\
    Model URL & https://sites.google.com/site/miraadastraiii/ \\
    Serial number & 1.0 \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Velden binnen de \ac{upnp} device description.}
\end{table}

Naast deze statische gegevens zullen we ook moeten voorzien in een unieke identifier die het toestel identificeert binnen het netwerk. Dit zullen we bespreken bij de effectieve implementatie van de kiosk.

\subsubsection{Service description}

Aangezien deze taak zal verzorgd worden door een applicatie geschreven in C++ (de motivaties hiervan worden later beschreven) is het moeilijker om de service description bestanden dynamisch te genereren. Meer nog, voor de library die we zullen gebruiken zullen we de description files manueel moeten uitschrijven. Hoewel niet zeer arbeidsintensief, is het een foutgevoelig proces dat we liefst niet teveel willen doen. Daarom hebben we eerst grondig nagedacht over hoe de service er moet uitzien, om pas daarna over te gaan tot de effectieve implementatie. Hoewel we nog altijd af en toe wijzigingen hebben moeten doorvoeren aan de service description files, is dit hierdoor tot een minimum beperkt gebleven.

\paragraph{Functionele opdeling}

Om een overvloed aan functies binnen een enkele service te vermijden, hebben we ervoor gekozen om een functionele opdeling door te voeren. Zo hebben we de service die toelaat om het toestel te controleren, met functies zoals \code{Shutdown} en \code{SetVolume}. Een tweede service staat vervolgens in voor acties die een impact hebben op de applicatie, zoals \code{LoadMedia}. Een bijkomend voordeel van deze scheiding is dat alle platform- of hardwareafhankelijke code geïsoleerd is binnen een enkele service, wat de implementatie ervan vereenvoudigt.

\begin{table}[h!]
  \begin{center}
    \begin{tabular}{p{4,5cm} p{5cm}}
    \multicolumn{2}{c}{\strong{Device service}} \\
    \hline
    \hline
    Functie & Beschrijving \\
    \hline
    \code{void Shutdown()} & Toestel afsluiten. \\
    \code{void Reboot()} & Toestel heropstarten. \\
    \code{void SetVolume(uint)} & Volume instellen. \\
    \code{uint GetVolume()} & Volume ophalen. \\
    \\
    \multicolumn{2}{c}{\strong{Application service}} \\
    \hline
    \hline
    Functie & Beschrijving \\
    \hline
    \code{void LoadMedia(string)} & Presentatie inladen. \\
    \end{tabular}
  \end{center}
  \caption{Enkele functies uit beide services.}
\end{table}

\paragraph{\ac{scpd} bestanden}

Zoals reeds gezegd zijn dit \ac{xml} bestanden die elk een service tot in alle details beschrijven. De exacte velden in deze bestanden worden opgelegd door de \ac{upnp} standaard, waardoor we ons soms in vreemde moeten wringen om toch een volledig compatibele service te bekomen. Strikte compatibiliteit is hierbij een vereiste omdat een van de libraries die we zullen gebruiken erop staat dat elk toestel volledig voldoet aan de \ac{upnp} specificatie. Een consequentie hiervan is bijvoorbeeld dat elke parameter van een functie moet overeen komen met een \code{state variable}, ook al heeft dat soms niet echt een praktisch nut. Fragment \ref{lst:scpd} bevat een gedeelte van de \ac{scpd} voor de device service.

\begin{lstlisting}[language=XML, float, caption=Voorbeeld van een \acs{scpd} bestand., label=lst:scpd]
<?xml version="1.0"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">
  <specVersion>
    <major>1</major>
    <minor>0</minor>
  </specVersion>
  <actionList>
    <action>
      <name>Shutdown</name>
    </action>
    <action>
      <name>SetVolume</name>
      <argumentList>
        <argument>
          <name>iVolumeValue</name>
          <relatedStateVariable>
            Volume
          </relatedStateVariable>
          <direction>in</direction>
        </argument>
      </argumentList>
    </action>
  </actionList>
  <serviceStateTable>
    <stateVariable sendEvents="no">
      <name>Volume</name>
      <dataType>ui1</dataType>
      <defaultValue>0</defaultValue>
    </stateVariable>
  </serviceStateTable>
</scpd>
\end{lstlisting}

\subsection{Presentatie}

De \ac{upnp} standaard voorziet tenslotte ook nog in een presentatie gedeelte, dat omschrijft dat een library kan voorzien in een webpagina waarmee een administrator eenvoudig de status van een device kan bekijken en eventueel acties uitvoeren. We hebben er echter voor gekozen dit niet te gebruiken, daar dit zou vereisen dat een administrator manueel surft naar de presentation URL's van elk device dat hij wil beheren. Het alternatief waarvoor we gekozen hebben is een webinterface aan de kant van de server, waarbij acties daar teweeggebracht door de serverapplicatie doorgestuurd worden naar de correcte kiosk.

\section{Redundantie en robuustheid}
\label{sec:redundantie}

Een belangrijk aspect van het systeem is dat het robuust is, en dus voorziet in een bepaalde vorm van redundantie. Zoals het hardwareontwerp zal verduidelijken (zie hoofdstuk \ref{ontwerp:hardware}), voorzien we reeds in hardwarematige redundantie onder de vorm van een RAID configuratie. Toch verhelpt dit het fundamentele probleem niet: de centrale server is een \emph{single point of failure}.

Een eerste idee om dit te verhelpen was het voorzien van een \strong{backup server}, die de centrale server continu zou monitoren. In geval van diens falen, zou de failover functionaliteit geactiveerd worden, waarbij de taken van de centrale server integraal overgenomen zouden worden. Gezien het configuratieloze aspect van de opstelling, en het feit dat elk initiatief steeds van de servers uit komt, zou dit totaal geen actie vereisen. Om ervoor te zorgen dat de backup server steeds over de meest recente informatie beschikt, activeert die tevens een (passieve) \ac{mdns} module, alsook registreert die zich bij de primaire server zodat updates aan de presentatie-repository steeds op beide servers aanwezig zijn.
Hoewel deze configuratie zeer elegant lijkt (zeker indien de replicatie alsook promotie/degradatie van de server volledig autonoom verloopt), is ze niet realistisch op budgettair vlak. Het is niet alleen kostelijk om een tweede voldoende krachtige server samen te stellen, maar de aanwezigheid ervan betekent een extra continue energieconsumptie.

Daarom hebben we gekozen voor een tweede piste, namelijk het gebruik van een \strong{backup-cache in de kiosken}. Aangezien embedded hardware vaak komt met een optie voor een kaartslot, is het voordeliger om voor elke kiosk een dergelijke geheugenkaart aan te kopen. De applicatie zal dan alle opgevraagde voorstellingen en configuratiegegevens lokaal opslaan. Wanneer vervolgens de centrale server onbereikbaar blijkt te zijn, kan steeds gebruik gemaakt worden van deze lokale cache om toch volwaardig te kunnen blijven functioneren.

\section{Server}
\label{ontwerp:applicatie:server}

Zoals reeds vermeld, is de centrale server van essentieel belang in het systeem. Zo verzorgt de server:
\begin{itemize}
\item Configuratie van de kiosken;
\item Opslag en distributie van de voorstellingen.
\end{itemize}

Naast deze elementaire taken, vereenvoudigt de server tevens de werklast van een administrator. We zullen immers voorzien in een beheerinterface die niet alleen een overzicht van het systeem biedt, maar ook toelaat om acties te ondernemen om eventuele problemen te verhelpen.

\subsection{Ontwikkelplatform}

De keuze van het ontwikkelplatform waarvoor we de serverapplicatie zullen ontwikkelen, is van vrij groot belang. Een goede keuze vereenvoudigt en versnelt de ontwikkeling, terwijl een verkeerde keuze tevens de kwaliteit van het eindproduct nadelig kan beïnvloeden.

Opnieuw bestaan er verschillende mogelijkheden die ons essentieel de middelen aanbieden om deze taak te volbrengen. Om een beslissing te kunnen maken, hebben we ons gefocust op de meestgebruikte entiteiten in de wereld van serverapplicaties, namelijk .NET en Java. Hoewel beide kandidaten relatief evenwaardig zijn in de context van deze serverapplicatie, hebben we voor het gemak gekozen voor ontwikkeling in Java. Deze keuze is gemotiveerd door voorgaande ervaringen, maar ook door het feit dat we een voorkeur hebben voor een Linux-gebaseerde omgeving en .NET daar niet goed met samenwerkt.

\subsection{Hergebruik}

\subsubsection{Repository}

De originele opzet was om via de serverside-bindings in de \ac{svn} bibliotheek te voorzien in een \ac{svn}-compatibele repository die volledig overkoepeld zou zijn door de serverapplicatie. Hierdoor zou het geheel een enkel monolitisch geheel vormen dat geen extra configuratie zou vereisen en niet zou berusten op externe applicaties. Om niet te moeten interfacen met de C-library zouden we daarvoor gebruik maken van de enige Java-wrapper voor de serverside-bindings die er bestaat: \makeurl{http://code.google.com/p/svnj/}{SVN-J}. Jammer genoeg bleek deze library niet stabiel genoeg te zijn, en ontbraken er verschillende features. Daarom hebben we jammer genoeg moeten kiezen voor een externe \ac{svn} repository, niet overkoepeld door de serverapplicatie.

\subsubsection{Netwerk}

Tijdens het ontwerp van het applicatieprotocol hebben we er speciaal op gelet om zoveel mogelijk bestaande technologieën te gebruiken, zodat we enerzijds niet steeds het wiel opnieuw uitvinden en anderzijds ook tijdens de realisatie gebruik zouden kunnen maken van bestaande hoogwaardige codebibliotheken.

\paragraph{Configuratie en invocatie} Zoals vermeld verloopt zowel het gros van de netwerkconfiguratie alsook het uitvoeren van acties via \ac{upnp}, wat we uit Java kunnen gebruiken door middel van de \makeurl{http://teleal.org/projects/cling/}{Cling} bibliotheek. Dit is een vrij volledige \ac{upnp} stack die de nadruk legt op strikte conformiteit en een duidelijke API. Hoewel er nog andere \ac{upnp} bibliotheken bestaan, zijn die vaak niet doorontwikkeld, proprietair of niet uitgebreid genoeg, waardoor Cling uiteindelijk de beste keus leek.

\paragraph{Data uitwisseling} Door gebruik te maken van een externe \ac{svn} instantie worden we geconfronteerd met nog een probleem: waar we anders vanuit de serverapplicatie toegang zouden gehad hebben tot de bestanden in de repository (die vervolgens via een \ac{svn}-compatibele interface zouden geopend worden naar eventuele clients toe), moeten we nu zelf contact opnemen met de externe \ac{svn} instantie om de nodige configuratiegegevens op te halen. Ook moet het mogelijk zijn snel te kijken wat de laatste revisie van de repository is, en om vervolgens op te halen wat er veranderd is sinds de laatst bekende revisie. Met die informatie kan bepaald worden welke configuraties en/of voorstellingen opnieuw moeten opgehaald worden, om daarna die informatie door te sturen naar de relevante kiosken.

Opnieuw bestonden er verschillende \ac{svn} bibliotheken, waaronder \makeurl{http://svnkit.com/}{SVNKit}. Deze actief ontwikkelde bibliotheek is geschreven in pure Java, wat het geheel volledig platformonafhankelijk maakt. Toch heeft dit ook een sterk nadeel: toen we de applicatie een eerste keer testen op een tragere computer duurde het verschillende minuten vooraleer SVNKit alle bestanden binnen gehaald had. Daarom hebben we vrij laat in het ontwikkelingsproces besloten om gebruik te gaan maken van de officiële Java bindings voor Subversion, die eigenlijk enkel een fijne wrapper zijn rond de C-library. Hierdoor is de library minder sterk object-georiënteerd, en wordt er minder gebruik gemaakt van typische Java-paradigma's. Een voordeel echter is dat de bibliotheek veel stabieler is, en ook ontwikkelingen aan de officiële Subversion code veel sneller kan opvolgen \citep{svn:javahl}.

\subsubsection{Beheerinterface}

\paragraph{Servlet engine} Om een website te kunnen realiseren, hebben we nood aan een servlet-engine. Binnen de Javawereld zijn er verschillende servlet engines, de bekendste wellicht Tomcat en Jetty. Aangezien onze applicatie niet draait rond de webapplicatie, maar dat slechts een deelcomponent is, zullen we geen gebruik kunnen maken van de standaard servlet environment. Door de servlet engine te \emph{embedden} binnen onze applicatie, is het eenvoudiger om tegelijk verschillende andere niet-webgeoriënteerde services actief te hebben. Zowel Tomcat als Jetty maken het mogelijk om ze te gebruiken binnenin een applicatie, al is het bij de ene al makkelijker dan bij de andere.

We stellen er echter een specifieke eis aan de servlet engine, namelijk dat we bij het genereren van een webpagina tegelijk toegang hebben tot de hele applicatie. Dit vinden we enkel terug bij Tomcat, Jetty start een nieuwe \ac{jvm}. Als we geen speciaal communicatieprotocol zoals \ac{rmi} willen gebruiken om data van de rest van de applicatie op te halen, kunnen we enkel Tomcat gebruiken.

\paragraph{Web tooklit} Nu de servlet engine vast ligt, moeten we nog bepalen met welke technologie we de servlets zullen bouwen. Om ons niet bezig te moeten houden met hoe de webpagina's gegenereerd worden, zijn we op zoek gegaan naar een widget-oriented framework voor moderne webapplicaties. Zo hebben we gekeken naar \strong{\makeurl{http://vaadin.com/home}{vaadin}}, een bibliotheek die toelaat om op een eenvoudige manier met enkel Java code een rijke user-interface te onwerpen. De manier van ontwikkelen leunt nauw aan bij hoe reguliere user-interfaces ontwikkeld worden: event- en widget gebaseerd, zonder zich te moeten bezig houden met het effectief genereren van de interface.

Een probleem met vaadin was echter dat het niet perfect werkt op oudere toestellen, en dat vrij veel code vereiste om een relatief eenvoudige \code{TreeView} op te bouwen. Daarom zijn we eens te meer op onze beslissing teruggekomen, en op zoek gegaan naar een betere toolkit. Zo zijn we gestuit op \strong{\makeurl{http://www.webtoolkit.eu/jwt}{JWt}}. Deze eveneens widget-oriented library heeft een zeer interessante feature, namelijk dat het voorziet in \emph{graceful degradation}. Hierbij zal de library detecteren wat de mogelijkheden zijn van de browser die de pagina opvraagt, en aan de hand daarvan meer of minder gesofisticeerde content genereren. Ook is zijn \ac{api} gemodelleerd naar de Qt \ac{api}, waarmee we reeds ervaring hadden. 

\subsubsection{Logging}

Ook zullen we gebruik maken van het \makeurl{http://logging.apache.org/log4j/1.2/}{Apache log4j} project, om op een uniforme wijze loginformatie te publiceren. Het pakket laat toe om in een extern configuratiebestand te specificeren welke deelmodules hoe gedetailleerd moeten loggen, en wat er met die informatie gedaan moet worden. Zo kunnen we eenvoudig configureren dat kritieke fouten van over heel het systeem moeten doorgemaild worden naar een administrator, of dat een deelsysteem dat nog niet perfect werkt, zoveel mogelijk informatie moet wegschrijven naar een speciaal logbestand.

\section{Kiosk}
\label{ontwerp:applicatie:kiosk}

Naast de server vormen de kiosken het tweede type toestel in het systeem. Een kiosk staat in voor:
\begin{itemize}
\item Weergave van voorstellingen;
\item Verwerken van gebruikersinvoer.
\end{itemize}

\subsection{Ontwikkelplatform}

De keuze van het ontwikkelplatform is eens te meer belangrijk voor het verloop van de ontwikkeling. Nu liggen de eisen echter anders: het platform moet low-level zijn, weinig afhankelijkheden hebben, en toelaten om performante applicaties te realiseren. Opnieuw beschouwen we enkel platformen die werken in combinatie met Linux-gebaseerde besturingssystemen, maar deze keer is de motivatie erachter anders: de meeste embedded hardware ondersteunt enkel een Linux-distributie. Gezien we het aantal afhankelijkheden ook beperkt willen houden, is een geïnterpreteerde taal niet ideaal.

Het ontwikkelplatform \makeurl{http://qt.nokia.com/}{Qt} voldoet vrijwel perfect aan dit eisenpakket. Het platform wordt gebruikt in combinatie met C++, een gecompileerde taal die zeer performante code toelaat. Qt zorgt er echter voor dat ontwikkeling van high-level applicaties zoals deze niet al te arbeidsintensief wordt in het relatief low-level C++. Zo komt Qt met een waaier aan interessante modules om snel een applicatie te realiseren, en breidt het C++ uit met enkele syntactische mogelijkheden die het eenvoudig maken om bepaalde high-level technieken te gebruiken. Bovendien is Qt inherent platform-onafhankelijk, waardoor het mogelijk wordt om de applicatie later eventueel te hergebruiken in een andere omgeving. Tenslotte biedt Qt ook een \emph{embedded mode}, waarin het zelf voorziet in een windowing system. Hierdoor worden enkele zware afhankelijkheden (zoals X11) vermeden.

\subsection{Hergebruik}

\subsubsection{Netwerk}

Net zoals dit bij de serverapplicatie het geval was, kunnen we door de nauwgezette selectie van protocollen optimaal gebruik maken van bestaande bibliotheken.

\paragraph{Configuratie en invocatie} Om een \ac{upnp} bibliotheek te vinden voor C++ moeten we niet lang zoeken. Toch zouden we met een "normale" C++ bibliotheek geen maximale integratie bekomen met de rest van de applicatie. Daarom zijn we specifiek op zoek gegaan naar een \ac{upnp} bibliotheek voor C++, die ook integreert met het Qt framework. Een eerste kandidaat hiervoor is de \makeurl{http://gitorious.org/qupnp}{Qt UPnP} bibliotheek, dewelke poogt een compacte en duidelijke UPnP implementatie te realiseren. Jammer genoeg blijkt dat project nog helemaal niet afgewerkt te zijn, meer nog, verschillende kritieke componenten ontbreken.

Een volgende kandidaat is de \makeurl{http://www.herqq.org/}{Herqq} bibliotheek, opnieuw een Qt-specifieke \ac{upnp} implementatie. De bibliotheek claimt een compacte implementatie conform de specificatie, en een eerste test ervan bleek ook zeer positief te zijn. Initieel zijn we dan ook begonnen met deze bibliotheek, maar hebben we na enkele weken ontwikkeling toch moeten opperen voor een bibliotheek. Het probleem was immers dat niet alleen de \ac{ssdp} configuraties, maar ook de devicegegevens statisch in een \ac{xml} bestand moesten doorgespeeld worden. Hierdoor zou het onmogelijk worden om \emph{at-runtime} een unieke identifier door te geven, waardoor we voor elke kiosk een speciaal configuratiebestand zouden moeten aanreiken. Omdat we uiteindelijk de code volledig generiek willen maken, is dit natuurlijk onaanvaardbaar.

Daarom hebben er uiteindelijk voor gekozen op de C++ \ac{upnp} bibliotheek van het \makeurl{http://brisa.garage.maemo.org/}{BRisa project} te gebruiken. Hoewel het in eerste instantie misschien minder duidelijk was wat de sterktes zijn van deze bibliotheek, maakte een eerste test al snel duidelijk dat ze niet moest onderdoen voor de Herqq \ac{upnp} bibliotheek. Omdat het bij deze bibliotheek wél mogelijk was om dynamisch devicegegevens door te spelen hebben we ervoor gekozen om het te gebruiken binnen de uiteindelijke applicatie.

\paragraph{Data uitwisseling} De kiosk moet in staat zijn een \ac{svn} repository te klonen indien de locatie ervan doorgespeeld geweest is. Hoewel we dit zouden kunnen doen door gebruik te maken van de \ac{svn} binary, is dit geen platform-onafhankelijke oplossing, die bovendien niet mooi te integreren valt binnen een applicatie. Daarom zijn we op zoek gegaan naar een C++ bibliotheek, liefst specifiek voor het Qt framework, die ons toelaat gegevens van een \ac{svn} repository binnen te halen zonder daarbij te berusten op een lokaal geïnstalleerde \ac{svn} applicatie. Zo zijn we terecht gekomen bij het \makeurl{http://kdesvn.alwins-world.de/}{KDESvn} project, een KDE frontend voor \ac{svn} repositories. We zijn natuurlijk niet geïnteresseerd in die applicatie, maar in de code die het gebruikt om toegang te krijgen tot \ac{svn} repositories. Daartoe heeft het KDESvn project een bibliotheek ontwikkeld, namelijk \makeurl{http://kdesvn.alwins-world.de/browser/trunk/src/svnqt}{svnqt}. Die bibliotheek is vrijwel volledig losgekoppeld van de KDESvn code, wat integratie binnen andere applicaties eenvoudig maakt (hiervan getuige bijvoorbeeld het \makeurl{http://www.anrichter.net/projects/qsvn}{QSvn} project).

\subsubsection{Weergave voorstellingen}

De voorstellingen zijn opgemaakt in een combinatie van \ac{html} en Javascript. Hierdoor kunnen we voor de weergave gebruik maken van de rendering engines ontwikkeld voor verschillende browsers. Zo is er de \makeurl{https://developer.mozilla.org/en/Gecko}{Gecko} rendering engine, ontwikkeld voor gebruik binnen de producten van Mozilla. Ondanks de recente port van Firefox naar het Qt platform, blijft de integratie van Gecko binnen Qt relatief moeilijk.

Daarom zullen we eerder kiezen voor de \makeurl{http://www.webkit.org/}{WebKit} rendering engine, een doorontwikkeling van de KHTML rendering engine. WebKit is een interessantere keuze gezien zijn populaire port naar het Qt framework, \makeurl{http://trac.webkit.org/wiki/QtWebKit}{QtWebKit}. Deze port is een officieel onderdeel van het Qt framework, waardoor het een goedgedocumenteerd en kwalitatief product is.

\subsubsection{Logging}

Net zoals we bij de serverapplicatie gekozen hebben voor een speciale loggingbibliotheek onder de vorm van log4j, maken we voor deze applicatie gebruik van het vergelijkbare \makeurl{http://log4qt.sourceforge.net/}{Log4Qt}. Dit is een port van log4j naar het Qt platform, zodat het mogelijk is om op een vergelijkbare manier te voorzien in uniforme logging die nauwgezet kan geconfigureerd worden. Omdat het originele project al enige tijd inactief is, zullen we wel gebruik maken van een meer actief ontwikkelde \makeurl{http://gitorious.org/log4qt}{fork} van Log4Qt. De fork is een doorontwikkeling van het originele project, met enkele bijkomend features en bugfixes.


%
% Hardware
%

\chapter{Hardware}
\label{ontwerp:hardware}

Gezien het beperkte budget is de zoektocht naar gepaste hardware best een uitdaging geweest.

\section{Kiosk}
\label{ontwerp:hardware:kiosk}

Algemeen worden er enkele vrij zware eisen gesteld aan de kioskhardware:
\begin{itemize}
\item Goedkoop: zowel betreffende aankoopprijs, als energieconsumptie;
\item Duurzaam: de hardware moet minstens 5 jaar meegaan;
\item Performant: de applicatie moet vlot werken, alsook een designer toelaten rijke voorstellingen te ontwerpen;
\item Stil.
\end{itemize}

\subsection{Type}

Vooraleer op zoek te gaan naar een specifiek hardwaremodel, is het belangrijk te kiezen wat voor soort hardware we zullen aankopen. Er zijn immers verschillende pistes, elk met hun voor- en nadelen.

\subsubsection{Tweedehands thin clients}

Een eerste richting die we verkend hebben, is die van hergebruik. Veel bedrijven hebben in het verleden gebruik gemaakt van thin clients, die wanneer het support-contract verloopt vaak voor een appel en een ei van de hand gedaan worden op populaire tweedehands-sites.

Hoewel dergelijke aanbiedingen wel interessant lijken, biedt een tweedehands thin client te weinig garanties om te gebruiken als hardware voor de kiosken. Zeker betreffende levensduur: een thin client die al vele jaren in werking is kan het steeds na enkele maanden reeds laten afweten, en gezien er geen stabiele bron aan identieke thin clients bestaat vormt dit een reëel probleem. Ook is de hardware extreem beperkt, zo komen thin clients vaak maar met enkele megabytes flash, waardoor de flexibiliteit van het nieuwe voorstellingenformaat snel ongedaan zou gemaakt zijn. Nieuwe thin clients, hoewel aantrekkelijker op hardwaregebied, zijn al helemaal geen optie: de supportcontracten die er altijd mee gepaard gaan duwen de prijs tot onredelijke hoogten, volledig ongeschikt voor de toepassing binnen dit project.

Daarom hebben we besloten om verder geen aandacht meer te besteden aan tweedehands thin clients, zelfs al zijn die op het eerste zicht qua prijs erg aantrekkelijk.

\subsubsection{Embedded hardware}

Embedded hardware is specifiek ontworpen voor toepassingen als deze. Hoewel vrij prijzig, biedt het daar veel in ruil voor: alle periferie is geïntegreerd op een enkele chip, vaak is er voorzien in specialistische acceleratie-chips, alsook zijn er features te vinden die interessant zijn voor embedded developers (zoals on-board flash, of een SD-kaartslot).

Ook de duurzaamheid is vaak indrukwekkend, mede door het feit dat er enkel solid-state componenten aanwezig zijn. Energieconsumptie is meestal ook een speerpunt, zo verbruikt de Beagleboard slechts 2.2 watt!

\subsubsection{Consument-georiënteerde hardware}

Hoewel niet echt geschikt voor dit doel, hebben we ook gekeken naar populaire consument-georiënteerde hardware. In die hardwarecategorie zijn er sinds enkele jaren energie-efficiënte configuraties te vinden, meestal bedoeld voor \ac{nas} toestellen of low-powered computers. Voorbeelden hiervan zijn moederborden gebaseerd op de \makeurl{http://www.intel.com/technology/atom/}{Intel Atom}, of de meer recent geïntroduceerde \makeurl{http://sites.amd.com/us/fusion/apu/Pages/fusion.aspx}{AMD Fusion}. Dergelijke moederborden komen vaak met een geïntegreerde \ac{gpu} (in het geval van de AMD Fusion zit die zelf op de processorchip) en andere periferie, waardoor het moederbord een handig functioneel geheel vormt.

Toch is er ook nood aan extra hardware, waaronder \ac{ram}, een harde schijf, en een voeding. Dat is dan ook direct een nadeel van deze piste: extra componenten verhogen de kans op falen. Andere features die dan wel geïntegreerd zijn op het moederbord, zijn volledig nutteloos voor dit project (zoals een RAID controller, of 5.1 audio).

Ondanks de nood aan die extra hardware blijft de prijs relatief aantrekkelijk. En voor die prijs wordt er meestal vrij veel pure performantie bekomen, wat het gemis aan interessante features deels tegemoet komt. Toch is dit, zeker gecombineerd met de teleurstellende duurzaamheid, niet voldoende om ons er voor te laten kiezen.

\subsubsection{Model}

Zoals uit de vorige paragraaf blijkt, is embedded hardware de meest geschikte keuze voor dit project. Maar hier eindigt het niet: er bestaan immers talloze modellen, van verschillende fabrikanten, met elk hun specifieke eigenschappen en mogelijkheden. We zochten naar de volgende features:
\begin{itemize}
\item Aansluitingsmogelijkheden: USB en HDMI;
\item Stereo audio;
\item 100 Mb ethernet;
\item Kaartslot;
\item Flash geheugen (512 MB of meer);
\item Voldoende performant.
\end{itemize}

Zo hebben we gekeken naar de populaire \strong{\makeurl{http://beagleboard.org/}{BeagleBoard}}, een compacte en vrij performante computer, met al de benodigde features en maar weinig meer. De computer komt ook met een speciale \ac{dsp}, alsook een \ac{gpu} die door Qt te gebruiken valt om de performantie te verhogen. Na echter contact opgenomen te hebben met de fabrikant, was die niet geïnteresseerd in de oplage die we zouden bestellen. Het bleek immers dat de BeagleBoard niet bedoeld is voor bedrijven, maar voor beginnende hardware-developers die voor weinig geld willen experimenteren met embedded development.

Daarom zijn we van de BeagleBoard afgestapt, om gelukkig een vergelijkbaar maar wel iets duurder geprijsd alternatief te vinden: de \strong{\makeurl{http://www.igep.es/index.php}{IGEPv2}}. Lange tijd hebben we dan ook gedacht dat dit de uiteindelijke keuze zou worden. Maar gezien dat iets hogere kostenplaatje, en het feit dat alle extra toebehoren (zoals een voeding, HDMI kabel, omhulsel) nog los moeten aangekocht worden, zijn we toch blijven uitkijken naar een alternatief.

\begin{figure}
	\includegraphics[width=\textwidth]{afbeeldingen/IGEPv2}
	\caption{IGEPv2 embedded computer.}
\end{figure}

Dat hebben we gevonden in de vorm van de \strong{\makeurl{http://www.globalscaletechnologies.com/t-guruplugdisplaydetails.aspx}{GuruPlug Display}}. Deze computer is misschien minder krachtig (vooral acceleratiemogelijkheden zijn een prominente afwezige), maar wordt geleverd als een sluitend geheel waarbij het standaardpakket tevens voorziet van alle nodige kabels.

\begin{figure}
	\includegraphics[width=\textwidth]{afbeeldingen/GuruPlug_Display}
	\caption{GuruPlug Display.}
\end{figure}

Verschillende maanden hebben we dan ook gedacht dat we de GuruPlug Display zouden gebruiken, meer nog: we waren reeds begonnen met de ontwikkeling van een besturingssysteem voor deze hardware. Er doken echter problemen op toen we tot aankoop van de hardware wouden overgaan. Vooreerst werd bij aankoop van een enkel device ter ontwikkeling van het besturingssysteem meer dan \euro 40 aan portkosten aangerekend, wat een significante meerkost betekende. Vervolgens liet het bedrijf achter de GuruPlugs weten dat er geen Europese modellen zouden gemaakt worden, waardoor we tevens een conversiestekker zouden moeten aankopen. Aangezien de hardware reeds niet al te performant was, hebben we wegens deze twee meerkosten besloten om opnieuw uit te gaan kijken naar een alternatieve oplossing, ondanks het feit dat we al begonnen waren met de effectieve implementatie.

Daarom zijn we op zoek gegaan naar een vergelijkbare plug-computer (zodat we niet veel werk zouden moeten herdoen), die beter leverbaar is, en dat liefst ook binnen Europa. Zo zijn we gestuit op de \strong{\makeurl{http://www.genesi-usa.com/products/efika}{EFIKA MX}} Smarttop computer, een computer vergelijkbaar met de GuruPlug. Meer zelfs, bepaalde elementen (zoals de \ac{cpu} generatie en de \ac{gpu}) hebben zelfs betere specificaties. Daartegenover staat dat er geen Bluetooth aanwezig is, alsook de prijs ietwat hoger ligt. Maar omdat Genesis een verdeler in het Verenigd Koninkrijk heeft, verdwijnt die meerkost daar we geen portkosten moeten betalen bij de uiteindelijke bestelling.

\begin{figure}
	\includegraphics[width=\textwidth]{afbeeldingen/EFIKA_MX}
	\caption{Genesis EFIKA MX.}
\end{figure}

\section{Input module}
\label{ontwerp:hardware:input}

De gebruiksinterface wordt gerealiseerd door 4 grote drukknoppen ingebouwd in de kast van elke kiosk. Momenteel worden deze knoppen intern doorverbonden met een afstandsbediening, waardoor de gebruiker via het indrukken van de knoppen indirect de DVD-speler kan besturen om zo een fragment te selecteren.

\begin{figure}
	\includegraphics[width=\textwidth]{afbeeldingen/kiosk_knoppen}
	\caption{Huidige aansluitingsmethode knoppen.}
\end{figure}

Nu we echter de DVD-spelers gaan vervangen door een computer, zullen we ook voor deze input module een compatibel alternatief moeten vinden. Aan deze module worden enkele specifieke eisen gesteld:
\begin{itemize}
\item Goedkoop: de module moet zo goedkoop mogelijk te produceren zijn, alsook mag het niet teveel energie verbruiken;
\item Toekomstgericht: aansluitmogelijkheden mogen geen gebruik maken van oude protocollen;
\item Gebruiksvriendelijk: installatie van de module moet eenvoudig zijn;
\item Snel: de tijd tussen het indrukken van een toets en registratie van het signaal moet minimaal zijn;
\item Uitbreidbaar: het moet mogelijk zijn om later extra toetsen aan te sluiten.
\end{itemize}

\subsection{Aansluiting}

Het grootste ontwerpprobleem hierbij is de manier van aansluiting die we zullen gebruiken om de module in verbinding te brengen met de rest van de kioskhardware. De meeste eenvoudige keuze zou die zijn van de \strong{parallelle poort}, waarbij we de pinnen van de poort vrijwel direct zouden kunnen verbinden met de knoppen. Jammer genoeg zijn parallelle poorten steeds schaarser, en komt die vrijwel nooit meer voor op embedded hardware. Een andere toegankelijke optie is de \strong{seriële poort}. Hierbij zou dan extra periferie benodigd zijn om in te staan voor de serialisatie van de signalen. Indien we echter platform-specifieke code toelaten, kunnen we de stuursignalen van de poort op een parallelle manier misbruiken zodat ook die periferie geëlimineerd wordt. Toch voldoet ook deze oplossing niet: ook de seriële poort wordt steeds schaarser, en alhoewel ze momenteel nog te vinden is op de meeste embedded-hardware bestaat de mogelijkheid dat dit binnen geringe tijd niet meer zo is.

Daarom hebben we uiteindelijk gekozen voor een poort die we normaal gezien wel nog enkele jaren zullen terugvinden op de meest courante hardware: de \ac{usb} poort. Deze veelzijdige poort laat ons doe om de input module te laten communiceren met een computer, en is ook relatief toekomstgericht (de recent geïntroduceerde \ac{usb} versie 3 is nog steeds volledig terugwaarts compatibel met \ac{usb} versie 1 toestellen). Maar het gebruik van \ac{usb} kent ook een nadeel: het protocol is immers pakket-georiënteerd, waardoor extra periferie een noodzaak is. Ook is de configuratie complexer, zeker indien we een toestel willen dat zonder speciale stuurprogramma's werkt op verschillende besturingssystemen.

\subsection{Realisatie \acs{usb}-communicatie}

Aangezien \ac{usb} een pakket-georiënteerd protocol is, hebben we steeds extra periferie nodig om de gebruikersinvoer door te sturen. Om geen speciale software te vereisen moet onze module een apparaat uit de \ac{usb} \ac{hid} klasse implementeren. Voor bepaalde subcategorieën van deze klasse (zoals toetsenborden, muizen, \dots) wordt immers gegarandeerd dat compatibele besturingssystemen er mee zullen kunnen omgaan zonder daarvoor extra stuurprogramma's nodig te hebben. Daarom zullen we onze module zichzelf laten identificeren als een toetsenbord, waarbij we dan in de Javascript code van de voorstellingen gepast kunnen reageren op dergelijke toetsaanslagen.

Om een \ac{usb} toetsenbord te realiseren, zijn we in eerste instantie op zoek gegaan naar \strong{\ac{usb} keyboard encoders}. In de huidige opzet hebben we echter maar nood aan 4 knoppen, terwijl de meeste keyboard encoders veel meer toetsen toelaten. Daarom is de prijs meestal ook een pak hoger, zo kost de \makeurl{http://www.ultimarc.com/ipacve.html}{I-Pac VE} keyboard encoder, die 32 toetsen toelaat, reeds \$35!

Daarom lijkt het interessanter om zelf te voorzien in de conversie naar \ac{usb}-pakketten, door gebruik te maken van een \strong{microcontroller met \ac{usb} hardware}. Dergelijke microcontrollers voorzien in on-chip \ac{usb} communicatiemogelijkheden, net zoals de meeste reguliere microcontrollers toelaten om gegevens over een seriële \ac{uart} te transporteren. Om vervolgens de \ac{usb} hardware op een toegankelijke manier te gebruiken, bestaan er verschillende bibliotheken zoals de officiële \ac{usb} bibliotheek van Atmel, of het open-source \makeurl{http://www.fourwalledcubicle.com/LUFA.php}{\ac{lufa}}. Het nadeel van deze piste is echter de meerkost van de \ac{usb} hardware, die eigenlijk onnodig is daar we enkel gebruik zullen maken van de \emph{low speed} overdrachtsmodus.

Een derde optie is om gebruik te maken van een \strong{microcontroller met \ac{usb} software}. Hierbij hebben we geen speciale hardware nodig, enkel een microcontroller die krachtig genoeg is om de \ac{usb} software uit te voeren. Het grote nadeel hieraan is dat het met de huidige microcontrollers enkel mogelijk is om gebruik te maken van \emph{low speed} \ac{usb}, maar voor onze toepassing is dit geen probleem. Opnieuw zijn er verschillende mogelijkheden om dit te realiseren, waarvan er een beschreven is in een \makeurl{http://www.atmel.com/dyn/resources/prod\_documents/doc2556.pdf}{application note} van Atmel. Deze application note gebruikt relatief weinig hardware om elementaire \ac{usb} communicatie te realiseren, maar zoals later zal blijken zijn er zelfs nog efficiëntere configuraties mogelijk. Ook is de software geschreven in AVR assembler, waardoor het geheel niet zo overdraagbaar is. Daarom zullen we gebruik maken van een open-source alternatief: de \makeurl{http://www.obdev.at/products/vusb/index.html}{V-USB} bibliotheek. Deze in C-geschreven bibliotheek biedt een eenvoudigere interface en daarbij ook verschillende voorbeeldprojecten om het gebruik ervan te illustreren.


%
% Licenties
%

\chapter{Licenties}

De keuze van een goede licentie is een element waar we niet te snel mogen over gaan. Elke licentie heeft immers verschillende vereisten en gevolgen, en ook ons eigen eisen verschillen van component tot component. Terzelfdertijd moet de gekozen licentie compatibel zijn met de verschillende bibliotheken die we gebruiken binnen de verschillende componenten. Ook willen we het eindresultaat openstellen voor open-source gebruik, waar zouden we anders staan moesten anderen dit nooit gedaan hebben. Tenslotte willen we ook de piste naar eventuele commercialisering open houden.

Het lijkt misschien moeilijk, al dan niet onmogelijk om hier allemaal rekening mee te houden, vooral als we tegelijk spreken over eventuele commercialisering en het product open-source maken. Toch is dit perfect mogelijk, en zijn er genoeg succesverhalen om dat mee te illustreren.

\section{Types licenties}

Vooraleer dieper in te gaan op hoe we open-source licenties kunnen gebruiken, is het interessant om een grove indeling te maken en zo enkele terugkerende eigenschappen te beschrijven. Hierbij identificeren we drie soorten open-source software: die in het publieke domein, die onder een permissive licentie, en die onder een copyleft licentie \citep{fsf:categories}.

\subsection{Copyleft licenties}

Bij dergelijke licenties wordt het copyright van de auteur gebruikt om te zorgen dat het herdistribueren van het product of een gewijzigde versie daarvan enkel gebeurt onder dezelfde of een compatibele licentie. Hiermee kan een auteur bijvoorbeeld erop toezien dat software die hij vrijgeeft, ook altijd vrij zal blijven. Bekende voorbeelden van deze licentie zijn de \ac{gpl}, of de \ac{cc-sa} licentie.

Binnen deze categorie maken we ook nog een onderscheid of het gaat over ``weak'' of ``strong'' copyleft. Het verschil tussen vindt men op vlak van afgeleid werkt. Meer bepaald, in het geval van weak copyleft vereist men niet dat het volledige product onder copyleft valt indien met enkel gebruikt maakt een project dat onder een copyleft licentie valt. Als dat project echter onder een strong copyleft licentie zou vallen, moet het volledige eindresultaat vrijgegeven worden onder een compatibele copyleft licentie.
Dit onderscheid is vooral van belang bij libraries: als die onder een weak copyleft licentie valt kan men de library gebruiken zonder de volledige applicatie te moeten vrijgeven. Wijzigingen aan de code zélf moeten echter wel vrijgegeven worden. Voorbeelden van weak copyleft licenties zijn de \ac{lgpl} en de \ac{mpl}.

Net zoals de \ac{lgpl} specificeert dat afgeleid werk niet onder de copyleft clausule valt, bestaat ook de \ac{agpl} waarbij men de copyleft eis laat vallen voor applicaties die gebruik maken van de gelicentieerde code via het netwerk. Dit is vooral interessant voor webservices, moesten deze immers onder de \ac{gpl} vallen dan zou ook elke applicatie die evvan gebruik maakt onder een \ac{gpl} compatibele licentie moeten vrijgegeven worden.

\subsection{Permissive licenties}

Hierbij is het niet langer vereist om wijzigingen aan de code vrij te geven. Hierdoor kan het dus zijn dat projecten die onder deze licentie gebruikt worden binnen proprietaire producten, en dit zelfs zonder eventuele wijzigingen aan die code te moeten vrijgeven. Vaak komen de licenties echter wel met een extra vereiste, maar die houdt vaak niet veel in. Zo stelt de \ac{mit} licentie dat de tekst ervan moet meegeleverd worden met het eindproduct, de Apache licentie eist datzelfde van een copyright notice en de disclaimer.

\subsection{Licenties zonder copyright}

Hoewel permissive licenties weinig of geen restricties stelden aan het gebruik van de code, blijft het copyright steeds in handen van de originele auteur. Indien we ook dit afstaan kan iedereen om het even wat mag doen met de code. Volledig het copyright afstaan, waarbij de code in het \emph{public domain} terechtkomt, is echter een complexe zaak: de situatie moet bekenen worden van land tot land, en soms is het zelf onmogelijk om de auteursrechten volledig af te staan.

Er bestaan verschillende licenties die code toekennen tot het public domain, waaronder de CreativeCommons Zero licentie en de \ac{wtfpl}.

\section{Open-source software commercialiseren}

Vaak wordt er met schrik gekeken naar open-source licenties omdat ze maar moeilijk passen binnen conventionele businessmodellen. Toch is het perfect mogelijk om dergelijke software te commercialiseren, mits een geschikte aanpak. We gaan nu twee dergelijke schema's beschrijven, elk een bedrijf die dit ook succesvol toegepast heeft als illustratie.

\subsection{Ondersteuning leveren}
\label{ontwerp:licenties:commercialiseren:ondersteuning}

Een model dat vaak toegepast wordt door fabrikanten van Linuxdistributies is het leveren van ondersteuning naast een gratis product. Een mooi voorbeeld hiervan is Red Hat, die verantwoordelijk is voor de \ac{rhel} distributie. Aangezien \ac{rhel} gebaseerd is op Linux en andere open-source componenten waarvan de overgrote meerderheid valt onder een copyleft of permissive licentie, mag Red Hat niet zomaar zijn product verkopen zonder er de broncode van vrij te geven. Toch zijn er veel diensten die Red Hat wel mag verkopen zonder enige bijkomende verplichting:
\begin{itemize}
  \item Toegang tot servers die updates verschaffen;
  \item Hulp bij installatie;
  \item Zelfgeschreven documentatie;
  \item Hardware (installatieschijven, \ldots).
\end{itemize}

Het is duidelijk dat \ac{rhel} een duidelijke meerwaarde heeft, ondanks het feit dat de broncode publiek beschikbaar is. Meer nog, het openen van de code naar een breder publiek opent verschillende opportuniteiten: externe programmeurs kunnen code toedragen, problemen worden sneller gevonden door het grotere testpubliek, \ldots

Een interessante opmerking is dat Red Hat wel het handelsmerk bezit op de naam \acl{rhel}. Het is dus perfect mogelijk om de broncode van \ac{rhel} te downloaden en een eigen product te lanceren, maar dit mag dan niet geadverteerd worden als zijnde \ac{rhel}. Dergelijke ``klonen'' bestaan ook, twee bekende voorbeelden zijn CentOS en \ac{sl}. Hoewel deze distributies gebaseerd zijn op dezelfde basissoftware, zijn het door de herimplementatie van de verschillende diensten die Red Hat commerciëel levert, toch heel andere producten.

\subsection{Herlicentiëren onder betaling}
\label{ontwerp:licenties:commercialiseren:herlicentieren}

Een tweede model berust op het feit dat commerciële partijen vaak geïnteresseerd zijn in non-copylefted software. We illustreren dit opnieuw met een concreet voorbeeld: het Qt framework dat ontwikkeld wordt door Nokia en uitgegeven wordt door Digia. Qt is beschikbaar onder verschillende licenties: een weak copyleft licentie, en een proprietaire licentie\footnote{Hoewel de site van Qt een ``commerciële licentie'' vermeld, gebruiken we de term ``proprietaire licentie'' omdat copylefted code ook perfect gecommercialiseerd kan worden (zie \ref{ontwerp:licenties:commercialiseren:ondersteuning}).}. Dankzij de weak copyleft licentie kan iedereen Qt downloaden, en er open-source of commerciële applicaties met maken. Dankzij de weak copyleft licentie moeten eventuele wijzigingen aan de Qt code wel steeds vrijgegeven worden.

Bedrijven hebben dit laatste vaak niet graag, ze willen wijzigingen kunnen doorvoeren aan de interne Qt code zonder die vervolgens te moeten publiceren. En dat is net waar Digia geld uit slaat: een bedrijf kan Qt gebruiken onder een proprietaire licentie, als het daar voor betaalt.

Hoe men net die conversie naar een commerciële licentie bekomt, kan op verschillende manieren. Als de auteur van de software in kwestie nog het volledige copyright bezit is het voor hem geen probleem om de licentie te veranderen. Van zodra er verschillende auteurs zijn wordt het echter complexer. Binnen een bedrijf is het logisch dat de code die een werknemer schrijft eigenlijk eigendom is van het bedrijf. Maar van zodra dat er externe auteurs zijn, wat vaak het gevolg is bij een open-source project, moeten er andere maatregelen getroffen worden om de code onder meerdere licenties te kunnen vrijgeven. De piste die Nokia en Digia gekozen hebben is die van een ``contribution agreement''. Hierbij staat een auteur toe dat zijn code kan gelicencieerd worden onder een proprietaire licentie. Andere bedrijven kiezen voor een rigide ``copyright assignment'', waarbij het copyright van de code volledig doorgegeven wordt aan het bedrijf in kwestie. Het ``voordeel'' van dit laatste is dat het bedrijf geen enkele verplichting heeft en later de licentie perfect kan veranderen. Bij een contribution agreement kan dit beperkt worden: in het geval van Qt wordt bijvoorbeeld gesteld dat de code en alle wijzigingen eraan steeds beschikbaar zullen blijven onder een copyleft licentie.

Merk op dat dit model enkel mogelijk is wanneer de code geen gebruik maakt van strong copylefted code. Als dit wel het geval is, kan de software nooit onder een proprietaire licentie verspreid worden.

\section{Keuze van licenties}

\subsection{Software}

Voor de applicaties die we ontwerpen voor dit project hebben we steeds gekozen voor een gepaste copyleft licentie. Door de code zomaar gratis op het internet te zetten krijgt het project extra visibiliteit en is het voor een derde partij gemakkelijker om het project op te pikken en te kijken of het wel past binnen zijn omgeving. Als die partij ook uiteindelijk besluit om met onze applicaties aan de slag te gaan, kan het daarbij verschillende pistes volgen:
\begin{enumerate}
  \item Het bedrijf gebruikt en adapteert onze code om binnen zijn omgeving te werken, en wordt daarbij door de licentie verplicht de wijzigingen terug te geven aan het project;
  \item Het bedrijf zou onze code willen gebruiken, maar heeft daarvoor extra ondersteuning nodig;
  \item Het bedrijf wil de code onder een proprietaire licentie verkrijgen om zo naar believen wijzigingen te kunnen doorvoeren.
\end{enumerate}
Elk van deze mogelijkheden komen het project ten goede: of er wordt code teruggegeven, of er wordt betaald voor bepaalde diensten. Wanneer het moment komt dat een externe partij code wil toedragen aan het project zullen we wel moeten zorgen voor een gepaste contribution agreement of zelfs copyright assignment, zodat het voor ons mogelijk blijft de code uit te geven onder een gesloten licentie voor propreitair gebruik.

\subsubsection{Serverapplicatie}

Voor deze applicatie lijkt een strong copyleft licentie de beste keuze. Een uitzonderingsmodule voor netwerkgebruik is hier niet echt nuttig aangezien de serverapplicatie eigenlijk methodes aanroept op de kioskapplicatie en zelf geen interface aanbiedt. Wanneer we later gebruik maken van een serverside \ac{svn} library om de repository te integreren binnen de serverapplicatie, zullen we wel nood hebben aan deze uitzonderingsmodule.

Laten we eerst kijken naar de externe projecten die we gebruiken binnen de applicatie:
\addtocounter{footnote}{1}
\footnotetext[\value{footnote}]{Dit is een permissive licentie die vereist dat naast een copyright notice en de disclaimer ook de documentatie steeds ter beschikking is.}
\addtocounter{footnote}{1}
\footnotetext[\value{footnote}]{Dit is een strong copyleft licentie waarbij bundeling onder een proprietaire licentie mogelijk is mits expliciete toestemming van TMate.}
\addtocounter{footnote}{-1}
\begin{table}[h!]
  \begin{center}
    \begin{tabular}{c c}
    Project & Licentie \\
    \hline
    log4j & Apache License versie 2.0 \\
    Tomcat & Apache License versie 2.0 \\
    Apache Commons & Apache License versie 2.0 \\
    Subversion & Apache License versie 2.0 \\
    XPP & Indiana University Extreme! Lab Software License$^{\decimal{footnote}}$\addtocounter{footnote}{1} \\
    JWt & \ac{gpl} versie 2 \\
    \end{tabular}
  \end{center}
  \caption{Open-source projecten binnen de serverapplicatie.}
\end{table}

\paragraph{Licentie} Om een licentie te kiezen moeten we nauwgezet analyseren met welke projecten die licentie compatibel is.  We willen bijvoorbeeld nagaan of we ons project kunnen distribueren onder de \ac{gpl}. De Apache 2 licentie is enkel compatibel met versie 3.0 van de \ac{gpl} \citep{fsf:comments}, en de \makeurl{http://www.extreme.indiana.edu/viewcvs/~checkout~/XPP3/java/LICENSE.txt}{Indiana University Extreme! Lab Software License} is een permissive licenie waardoor ze vast en zeker compatibel is met de \ac{gpl}. Het is dus duidelijk dat we de serverapplicatie enkel onder versie 3 van de \ac{gpl} (of afgeleiden) kunnen uitgeven.

\paragraph{Herlicentiëren} Zoals beschreven in sectie \ref{ontwerp:licenties:commercialiseren:herlicentieren} willen we het mogelijk houden om onder betaling de code onder een proprietaire licentie te verkopen. Niet alle projecten die we hergebruiken zijn echter compatibel met een dergelijke licentie! Voor de projecten onder een permissive licentie (log4j, Tomcat, Apache Commons, XPP) is er geen probleem, we moeten enkel zorgen dat we voorzien in de tekst van de licentie, een copyright notice, en eventueel andere documenten. Maar overige project, JWt, valt onder de strong copyleft \ac{gpl} die niet compatibel is met een proprietaire licentie. Als we beter kijken zien we echter dat ze hetzelfde model hanteren als dat wij beschreven hebben in sectie \ref{ontwerp:licenties:commercialiseren:herlicentieren}: mits betaling is het mogelijk om dezelfde code te verkrijgen onder een proprietaire licentie. Als we dus de code van JWt aankopen is het perfect mogelijk om onze serverapplicatie te verkopen onder een proprietaire licentie.

\subsubsection{Kioskapplicatie}

Opnieuw zullen we kijken in welke mate we een strong copyleft licentie kunnen toepassen op onze code. Aangezien de kioskapplicatie een \ac{upnp} service aanbiedt, zullen we nu echter wel aandacht moeten besteden aan de \ac{agpl}, die een copyleft uitzonderingsclausule voor netwerkgebruik aan boord heeft.

Vooreerst kijken we naar de licenties van externe projecten die we gebruiken:
\begin{table}[h!]
  \begin{center}
    \begin{tabular}{c c}
    Project & Licentie \\
    \hline
    Log4Qt & Apache License versie 2.0 \\
    BRisa UPnP & \ac{lgpl} 3.0 \\
    Qt & \ac{lgpl} versie 2.1 en 3.0 \\
    libqxt & \ac{lgpl} versie 2.1 \\
    \end{tabular}
  \end{center}
  \caption{Open-source projecten binnen de kioskapplicatie.}
\end{table}

\paragraph{Licentie} De situatie is hier iets eenvoudiger dan bij de serverapplicatie. Door het gebruik van een project dat valt onder versie 2.0 van de Apache License, kunnen we eigenlijk al maar enkel gebruik maken van versie 3.0 van de \ac{gpl}. Die licentie is vervolgens compatibel met de overige licenties waarvan we gebruik maken.

Maar aangezien de applicatie een webservice aanbiedt wouden we gebruik maken van de \ac{agpl}. Als we in detail kijken naar de tekst van die licentie zien we dat vanaf versie 3 er in beide licenties een expliciete clausule \citetext{\citealp[sectie 13]{fsf:gpl}; \citealp[sectie 13]{fsf:agpl}} is opgenomen die ze compatibel maakt. Daardoor kunnen we zonder probleem de code onder versie 3 van de \ac{agpl} laten vallen.

\paragraph{Herlicentiëren} Ook dit aspect is gemakkelijker voor de kioskapplicatie. Een proprietaire licentie is immers toegelaten door de permissive licentie waaronder Log4Qt valt, en de overige projecten gebruiken een weak copyleft licentie die expliciet stelt dat copyleft niet van toepassing is indien we enkel linken met de code. Wijzigingen aan de code zelf moeten wel vrijgegeven worden, maar dat hebben we ook gedaan (zie deel \ref{kiosk}).

\subsubsection{Firmware inputmodule}

De firmware maakt maar gebruik van 1 extern project: V-USB. Dit project valt opnieuw onder een duale licentie: enerzijds de \ac{gpl}, en anderzijds een licentie die mits betaling gebruik binnen een proprietair project toelaat.

\paragraph{Licentie} De situatie is hier vrij eenvoudig: we moeten enkel compatibel zijn met de \ac{gpl} waaron het V-USB project valt. Daarom zullen we zelf ook kiezen om gebruik te maken van de \ac{gpl}.

\paragraph{Herlicentiëren} Net zoals bij JWt valt V-USB onder een duale licentie waardoor gebruik binnen een proprietair project enkel mogelijk is mits aankoop van de code onder een compatibele licentie.

\subsection{Hardware inputmodule}

Aangezien veel van de termen die gebruik worden binnen software-georienteerde licenties zoals de \ac{gpl} niet van toepassing zijn op hardware (zo is het bij software al moeilijk genoeg om ``afgeleid werk'' nauwkeurig te omschrijven), kiezen we ervoor om gebruik te maken van een licentie die specifiek ontworpen is voor open-source hardware. Toch willen we niet teveel afwijken van het strong copyleft principe, aangezien dat een elementair deel is van het business model achter dit project. Daarom maken we gebruik van \makeurl{http://www.ohwr.org/attachments/662/CERNOHLv1\_1.pdf}{versie 1.1 van de CERN \ac{ohl}}, een strong copyleft licentie specifiek ontworpen voor hardware. We halen snel de belangrijkste elementen van de licentie aan:

\begin{itemize}
  \item Copyright en handelsmerken blijven behouden bij de originele auteur;
  \item Distributie van het project is toegelaten, maar in het geval van wijzigingen moeten de designdocumenten toegankelijk zijn en onder een compatibele licentie vrijgegeven worden;
  \item Productie en distributie van de hardware is toegelaten.
\end{itemize}

Hoewel commercialisering van dit product hiermee mogelijk is, zoals altijd kunnen we de licentie veranderen naar iets dat compatibel is met proprietair gebruik, is de kans klein dat we dit ooit zullen moeten doen. Het product is immers zo specifiek aan de situatie waarbinnen het gebruikt wordt dat het wellicht weinig nut zal hebben buiten de MIRA.

\subsection{Scriptie}

Het laatste item waar we een gepaste licentie moeten voor vinden, is dit document zelf. Hierbij hebben we een ander doel voor ogen dan bij de software en hardware: eventuele commercialisering is niet relevant. Het zou ook interessant zijn om gequote te kunnen worden zonder dat daarbij het werk waarin de quote terecht komt onder dezelfde termen moet vrijgegeven worden. Een copyleft licentie is dus niet gewenst, maar ook de meeste perimssive licenties zijn te software georienteerd om op een zinnige manier toegepast te kunnen worden op dit document.

Een verzameling licenties die vaak gebruikt worden buiten de softwarewereld, zijn de \makeurl{https://creativecommons.org/}{\acl{cc}} licenties. Deze licenties bevatten weinig of geen termen die specifiek zijn aan software, en werken volgens een modulair principe: afhankelijk van de specifieke eisen van de auteur kiest hij voor een aantal plugins die het hergebruik van zijn werk beperken. Zo zijn er de volgende plugins:
\begin{itemize}
  \item Attribution (BY): de auteur moet altijd expliciet vermeld blijven;
  \item Noncommercial (NC): het werk mag niet gebruikt worden voor commerciële doeleinden;
  \item No derivative works (ND): enkel exacte kopieën van het werk mogen gedistribueerd worden;
  \item Share-alike (SA): het werk moet onder een vergelijkbare licentie verdeeld worden (cfr. copyleft).
\end{itemize}

Voor deze scriptie willen we enkel dat de auteur correct geattribueerd wordt indien er naar het werk verwezen wordt of er fragmenten uit gebruikt worden. Daarom zullen we kiezen voor de \ac{cc-by} licentie. We hebben we gekozen voor een oudere versie van deze licentie, namelijk versie 2.0 in plaats van versie 3.0, omdat er enkel van die versie een Belgische versie bestaat.
