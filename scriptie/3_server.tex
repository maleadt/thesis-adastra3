\part{Server}
\label{server}

\chapter{Structuur}

Op het hoogste niveau hebben we de serverapplicatie onderverdeeld in enkele logische subsystemen, zijnde het netwerk, de repository, en tenslotte de webinterface. Onderling communiceren deze subsystemen niet met elkaar: co√∂rdinatie verloopt door een overkoepelende controller. Zo is het mogelijk om elk subsysteem als een alleenstaand geheel te behandelen, wat het ontwikkelingsproces sterk vereenvoudigt.

Om code te abstraheren en controle van subsystemen te vereenvoudigen moet elk van de subsystemen een bepaalde klasse uitbreiden met de concrete implementatie. Die klasse voorziet niet alleen in bepaalde gedeelde functionaliteit (zoals het genereren van log berichten, of inladen van de nodige configuratiebestanden), maar schrijft ook voor hoe de effectieve implementatie moet gevormd worden. Hierdoor wordt het eenvoudig om vanuit de applicatiecontroller op een eenduidige manier bepaalde standaardacties (zoals het opstarten of afsluiten van een subsysteem) uit te voeren.

\section{Netwerk subsysteem}

Het netwerk subsysteem verzorgt wat we in de vorige hoofdstukken tot applicatieprotocol gedoopt hebben. Het subsysteem is opgesplitst in enkele samenwerkende componenten: vooreerst is er het gedeelte dat dient als main entrypoint voor andere componenten die willen gebruik maken van het netwerksubsysteem. Daartoe biedt het bijvoorbeeld een lijst van aanwezige kiosken, en kan voor elke kiosk een object opgevraagd worden dat toelaat om gegevens op te halen of acties uit te voeren. Ook is er voor zien in de nodige functionaliteit om signalen door te geven, bijvoorbeeld om geschikt te reageren op de toevoeging van een nieuwe kiosk.
Door al deze functionaliteit te bundelen in een enkele klassie, is dit de enige interface tussen het volledige subsysteem en de rest van de applicaties. De uiteindelijke implementatie van het subsysteem kan hierdoor eenvoudig gewijzigd worden, zonder veel te moeten veranderen aan componenten die gebruik maken van dit systeem.

Het netwerk subsysteem bevat ook nog een gedeelte dat instaat voor de effectieve monitoring van het netwerk. Dit gedeelte is puur intern, en het is niet de bedoeling dat een externe component communiceert met deze netwerk monitor. Als de monitor bepaalde informatie wil vrijgeven aan de buitenwereld (wat bijvoorbeeld voorkomt als het een nieuwe kiosk detecteerd), zal het dit doorgeven aan de publieke component van het netwerk subsysteem, waarna die vermoedelijk bepaalde signalen zal uitsturen. Hoewel dit geconvolueerd mag lijken is dit een hele interessant design: zoals hierboven vermeld mogen we nu steeds de monitor naar believen aanpassen, zolang de publieke interface maar dezelfde blijft zal niemand hier iets merken.

% todo: vermelden brisa, objecten met actions, blabla. sdp mss ook, hoe impl enzo

% todo: brisa en upnp en ssdp enzo al in hfds 2?

\section{Repository subsysteem}

Dit systeem dient als wrapper rond de repository waarbinnen alle gegevens van het systeem (configuraties, interfaces, en de media) opgeslagen zijn. We verwerken wel niet alle gegevens binnen de repository: enkel de kioskconfiguraties zijn van belang voor de server. Vervolgens kunnen de kiosken manueel interfaces en mediagegevens inladen.
% todo: vermelden bij ontwerp waarop gesplitst
% niet alles vo server: doorsturen moeilijk
% niet alles in kiosk: te statisch
% hier nog eens snel herhalen

De elementaire structuur van dit subsysteem kent veel gelijkenissen met het netwerk subsysteem: zo is er een publieke interface die interactie van buitenaf toelaat en de nodige signalen uitstuurt, alsook is er een private repository monitor die ervoor zorgt dat de data up-to-date is.

% todo: svn lib vermelden.

\section{Website subsysteem}

\section{Applicatiecontroller}

% controller
% service modules
% blabla

\chapter{Realisatie}

% duur
% grootorde
% problemen
% resultaat

\chapter{Deployment}

% modules van maven
% fatjar
% integreren in linux os (debian)
